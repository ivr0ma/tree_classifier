#include "Classifier.h"

using namespace std;

//
// конструктор класса, осуществляет начальную инициализацию
//
Classifier::Classifier() {
    work_tag[0][0] = 0; // признак 1 для узла 1
    work_tag[0][1] = 3; // признак 2 для узла 1
    work_tag[1][0] = 3; // признак 1 для узла 2
    work_tag[1][1] = 4; // признак 2 для узла 2
    work_tag[2][0] = 4; // признак 1 для узла 3
    work_tag[2][1] = 8; // признак 2 для узла 3

    func_coef[0][0] = -69.78;  // с1 для узла 1
    func_coef[0][1] = -1.96;   // с2 для узла 1
    func_coef[1][0] = -156.65; // с1 для узла 2
    func_coef[1][1] = -4.75;   // с2 для узла 2
    func_coef[2][0] = 45.58;   // с1 для узла 3
    func_coef[2][1] = -0.416;  // с2 для узла 3

    read_file();
}

//
// считываем объекты классов A,B,C,D из файла
//
void Classifier::read_file() {
    //FILE* f = fopen(file_path, "r");
    int a;
    int M[60][10] = {
            {18, 19, 22, 55, 35, 17, 11, 14, 29, 22},
            {17, 16, 26, 56, 34, 18, 13, 11, 23, 34},
            {15, 12, 38, 57, 30, 13, 19, 16, 32, 36},
            {16, 11, 32, 57, 32, 19, 16, 19, 38, 26},
            {19, 17, 24, 57, 37, 16, 12, 13, 26, 22},
            {15, 18, 22, 59, 30, 12, 11, 15, 31, 30},
            {17, 13, 34, 60, 33, 11, 17, 12, 24, 32},
            {18, 11, 36, 60, 36, 17, 18, 21, 43, 38},
            {18, 15, 26, 61, 35, 18, 13, 19, 37, 34},
            {14, 16, 22, 62, 28, 13, 11, 13, 25, 24},
            {17, 19, 30, 62, 33, 11, 15, 13, 26, 26},
            {15, 17, 32, 63, 30, 15, 16, 12, 24, 22},
            {18, 12, 38, 63, 35, 16, 19, 20, 39, 30},
            {16, 13, 34, 64, 32, 19, 17, 11, 21, 32},
            {15, 11, 24, 65, 29, 17, 12, 15, 31, 38},
            {27, 15, 26, 37, 53, 12, 13, 17, 35, 34},
            {28, 16, 22, 38, 55, 19, 11, 19, 39, 26},
            {25, 19, 30, 39, 50, 16, 15, 16, 32, 38},
            {29, 17, 32, 39, 57, 12, 16, 24, 48, 32},
            {24, 13, 38, 41, 47, 11, 19, 23, 45, 24},
            {27, 19, 34, 41, 54, 17, 17, 20, 41, 22},
            {22, 16, 26, 42, 43, 18, 13, 27, 53, 34},
            {26, 12, 38, 42, 51, 13, 19, 25, 51, 36},
            {27, 19, 32, 43, 55, 11, 16, 23, 47, 22},
            {21, 16, 24, 44, 41, 15, 12, 28, 56, 28},
            {25, 12, 22, 44, 49, 16, 11, 21, 42, 34},
            {23, 11, 34, 45, 46, 19, 17, 18, 36, 26},
            {26, 17, 36, 45, 52, 17, 18, 16, 31, 38},
            {22, 18, 22, 46, 43, 12, 11, 15, 30, 32},
            {24, 13, 28, 47, 47, 13, 14, 26, 51, 24},
            {30, 11, 34, 51, 60, 11, 17, 18, 36, 22},
            {28, 15, 26, 52, 56, 15, 13, 23, 47, 34},
            {32, 16, 38, 52, 64, 16, 19, 25, 50, 36},
            {26, 19, 32, 53, 52, 19, 16, 14, 28, 22},
            {30, 17, 24, 53, 59, 17, 12, 13, 26, 28},
            {28, 12, 22, 54, 55, 13, 11, 11, 23, 30},
            {31, 13, 34, 54, 61, 19, 17, 19, 37, 26},
            {33, 11, 36, 54, 65, 16, 18, 10, 21, 38},
            {25, 15, 22, 55, 50, 12, 11, 12, 25, 22},
            {29, 16, 28, 56, 58, 11, 14, 15, 30, 34},
            {32, 19, 30, 56, 63, 17, 15, 13, 26, 36},
            {27, 17, 26, 57, 54, 18, 13, 11, 22, 26},
            {26, 13, 38, 58, 51, 17, 19, 25, 51, 22},
            {30, 19, 34, 58, 60, 18, 17, 21, 42, 30},
            {28, 16, 24, 59, 56, 13, 12, 19, 38, 32},
            {37, 12, 36, 35, 74, 15, 18, 16, 33, 38},
            {33, 19, 26, 41, 67, 16, 13, 14, 27, 34},
            {34, 16, 22, 37, 68, 19, 11, 11, 21, 24},
            {35, 12, 30, 47, 69, 17, 15, 19, 37, 26},
            {35, 11, 32, 43, 70, 12, 16, 10, 21, 22},
            {36, 17, 38, 41, 71, 13, 19, 15, 31, 30},
            {35, 18, 34, 36, 71, 11, 17, 17, 33, 32},
            {37, 13, 24, 43, 73, 15, 12, 21, 42, 38},
            {37, 11, 26, 38, 74, 16, 13, 23, 45, 34},
            {38, 15, 22, 48, 75, 19, 11, 16, 32, 26},
            {39, 16, 30, 43, 77, 17, 15, 14, 27, 38},
            {39, 19, 32, 38, 77, 13, 16, 13, 26, 22},
            {39, 17, 38, 34, 78, 19, 19, 18, 36, 34},
            {40, 12, 34, 38, 80, 16, 17, 21, 42, 36},
            {41, 13, 26, 42, 81, 12, 13, 13, 26, 26}
    };

    // читаем данные из файла и заносим их в массивы
    for (int i = 0; i < 60; i++) {
        for (int j = 0; j < 10; j++) {
            a = M[i][j];
            if (i < 15) {
                cl_A[i][j] = a;
                cl_AC[i][j] = a;
            }
            else if (i < 30) {
                cl_B[i - 15][j] = a;
                cl_BD[i - 15][j] = a;
            }
            else if (i < 45) {
                cl_C[i - 30][j] = a;
                cl_AC[i - 15][j] = a;
            }
            else {
                cl_D[i - 45][j] = a;
                cl_BD[i - 30][j] = a;
            }

        }
    }
}

//
// считает расстояние между объектами класса
//
double Classifier::distance(int node_num, int* x, int* y) {
    int f1, f2;

    f1 = work_tag[node_num][0];
    f2 = work_tag[node_num][1];

    return sqrt((x[f1] - y[f1]) * (x[f1] - y[f1]) + (x[f2] - y[f2]) * (x[f2] - y[f2]));
}

//
// реализация дискриминантной функции
//
int Classifier::discr_func(int node_num, int* obj) {
    // F = c1 - c2*x2 - x1
    // определяем коэффициенты для дискриминантной функции
    double c1, c2, x1, x2, F;
    c1 = func_coef[node_num][0];
    c2 = func_coef[node_num][1];
    x1 = obj[work_tag[node_num][0]];
    x2 = obj[work_tag[node_num][1]];

    F = c1 - c2 * x2 - x1; // дискриминантная функция

    // классификация объекта в зависимости от узла
    if (node_num == 0) {
        if (F > 0)
            return 0;
        else
            return 1;
    }
    else if (node_num == 1) {
        if (F > 0)
            return 1;
        else
            return 0;
    }
    else {
        if (F > 0)
            return 0;
        else
            return 1;
    }
}

//
// реализация метода 1-го ближайшего соседа
//
int Classifier::neighbour_1(int node_num, int* obj) {
    double min1, min2; // минимумы
    double curr;       // тек. значение
    int(*M1)[10]; // класс 1
    int(*M2)[10]; // класс 2
    int n1, n2;   // размерности классов 1 и 2 соответсвенно

    // определение классов для каждого узла
    if (node_num == 0) {
        M1 = cl_AC;
        M2 = cl_BD;
        n1 = 30;
        n2 = 30;
    }
    else if (node_num == 1) {
        M1 = cl_A;
        M2 = cl_C;
        n1 = 15;
        n2 = 15;
    }
    else {
        M1 = cl_B;
        M2 = cl_D;
        n1 = 15;
        n2 = 15;
    }

    // инициализируем переменную
    min1 = distance(node_num, obj, M1[0]);

    // поиск минимума
    for (int i = 1; i < n1; i++) {
        curr = distance(node_num, obj, M1[i]);
        if (curr < min1)
            min1 = curr;
    }

    // инициализируем переменную
    min2 = distance(node_num, obj, M2[0]);

    // поиск минимума
    for (int i = 1; i < n1; i++) {
        curr = distance(node_num, obj, M2[i]);
        if (curr < min2)
            min2 = curr;
    }

    if (min1 < min2)
        return 0;
    else
        return 1;
}

//
// реализация метода k ближайших соседей
//
int Classifier::neighbour_k(int k, int node_num, int* obj) {
    double* min1, * min2; // минимумы
    double curr;          // тек. значение
    int(*M1)[10]; // класс 1
    int(*M2)[10]; // класс 2
    int n1, n2;   // размерности классов 1 и 2 соответсвенно
    int count;    // голосование для классификации

    // определение классов для каждого узла
    if (node_num == 0) {
        M1 = cl_AC;
        M2 = cl_BD;
        n1 = 30;
        n2 = 30;
    }
    else if (node_num == 1) {
        M1 = cl_A;
        M2 = cl_C;
        n1 = 15;
        n2 = 15;
    }
    else {
        M1 = cl_B;
        M2 = cl_D;
        n1 = 15;
        n2 = 15;
    }

    // если ошибочные данные
    if (k > n1 || k > n2)
        return -1;

    min1 = new double[k];
    min2 = new double[k];

    // инициализируем массив минимумов
    for (int j = 0; j < k; j++) {
        min1[j] = distance(node_num, obj, M1[j]);
    }

    // сортировка массива
    for (int j = 1; j < k; j++) {
        for (int i = 0; i < k - 1; i++) {
            if (min1[i] > min1[i + 1]) {
                curr = min1[i];
                min1[i] = min1[i + 1];
                min1[i + 1] = curr;
            }
        }
    }

    // поиск вектора минимумов
    for (int i = k; i < n1; i++) {
        curr = distance(node_num, obj, M1[i]);
        for (int j = 0; j < k; j++) {
            if (curr < min1[j]) {
                for (int r = j; r < k - 1; r++) {
                    min1[r + 1] = min1[r];
                    min1[r] = curr;
                }
            }
        }
    }

    // инициализируем массив минимумов
    for (int j = 0; j < k; j++) {
        min2[j] = distance(node_num, obj, M2[j]);
    }

    // сортировка массива
    for (int j = 1; j < k; j++) {
        for (int i = 0; i < k - 1; i++) {
            if (min2[i] > min2[i + 1]) {
                curr = min2[i];
                min2[i] = min2[i + 1];
                min2[i + 1] = curr;
            }
        }
    }

    // поиск вектора минимумов
    for (int i = 0; i < n2; i++) {
        curr = distance(node_num, obj, M2[i]);
        for (int j = 0; j < k; j++) {
            if (curr < min2[j]) {
                for (int r = j; r < k - 1; r++) {
                    min2[r + 1] = min2[r];
                    min2[r] = curr;
                }
            }
        }
    }

    // голосование, выбор ближайшего класса
    count = 0;
    for (int i = 0; i < k; i++) {
        if (min1[i] > min2[i])
            count++;
    }

    delete[] min1;
    delete[] min2;

    if (count >= k / 2)
        return 1;
    else
        return 0;
}

//
// функция голосования
//
bool Classifier::voting(int node_num, int* obj) {
    return discr_func(node_num, obj) + neighbour_1(node_num, obj) + neighbour_k(3, node_num, obj) >= 2;
}

//
// классификация объекта
//
char Classifier::recognize(int* obj) {
    // обход дерева и запуск функции голосования для каждого узла
    if (!voting(0, obj)) {
        if (!voting(1, obj))
            return 'A';
        else
            return 'C';
    }
    else {
        if (!voting(2, obj))
            return 'B';
        else
            return 'D';
    }

}